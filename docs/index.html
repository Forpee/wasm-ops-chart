<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>WebAssembly Opcode Table</title>
	<!-- <p>WebAssembly is an open, industry-wide effort to bring a safe, efficient assembly language to the web. WebAssembly technology is developed collaboratively by major browser vendors including Mozilla, Google, Microsoft, and Apple. WebAssembly modules can be downloaded and executed by the majority of browsers in use today.</p> -->
	<!-- https://atomiks.github.io/tippyjs/ -->
	<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
	<script src="https://unpkg.com/popper.js@1"></script>
	<script src="https://unpkg.com/tippy.js@5/dist/tippy-bundle.iife.min.js"></script>

	<script src="https://unpkg.com/xregexp/xregexp-all.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet"/>

	<link href="html/optable.css" rel="stylesheet"/>
	<script src="html/optable.js"></script>
</head>
<body>

<h1>WebAssembly Opcodes</h1>
<!-- by Pengo Wray -->
<table id="opcodes">
<thead>
<tr>
<th>&nbsp;</th>
<th>_0</th>
<th>_1</th>
<th>_2</th>
<th>_3</th>
<th>_4</th>
<th>_5</th>
<th>_6</th>
<th>_7</th>
<th>_8</th>
<th>_9</th>
<th>_A</th>
<th>_B</th>
<th>_C</th>
<th>_D</th>
<th>_E</th>
<th>_F</th>
</tr>
</thead>
<tbody>
<tr>
<th scope="row">0_</th>
<td>unreachable</td>
<td>nop</td>
<td>block</td>
<td>loop</td>
<td>if</td>
<td>else</td>
<td>*try</td>
<td>*catch</td>
<td>*throw</td>
<td>*rethrow</td>
<td></td>
<td>end</td>
<td>br</td>
<td>br_if</td>
<td>br_table</td>
<td>return</td>
</tr>
<tr>
<th scope="row">1_</th>
<td>call</td>
<td>call_indirect</td>
<td>*return_call</td>
<td>*return_call_indirect</td>
<td>*call_ref</td>
<td>*return_call_ref</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>*delegate</td>
<td>*catch_all</td>
<td>drop</td>
<td>select</td>
<td>*select t</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<th scope="row">2_</th>
<td>local.get</td>
<td>local.set</td>
<td>local.tee</td>
<td>global.get</td>
<td>global.set</td>
<td>*table.get</td>
<td>*table.set</td>
<td>&nbsp;</td>
<td>i32.load</td>
<td>i64.load</td>
<td>f32.load</td>
<td>f64.load</td>
<td>i32.load8_s</td>
<td>i32.load8_u</td>
<td>i32.load16_s</td>
<td>i32.load16_u</td>
</tr>
<tr>
<th scope="row">3_</th>
<td>i64.load8_s</td>
<td>i64.load8_u</td>
<td>i64.load16_s</td>
<td>i64.load16_u</td>
<td>i64.load32_s</td>
<td>i64.load32_u</td>
<td>i32.store</td>
<td>i64.store</td>
<td>f32.store</td>
<td>f64.store</td>
<td>i32.store8</td>
<td>i32.store16</td>
<td>i64.store8</td>
<td>i64.store16</td>
<td>i64.store32</td>
<td>memory.size</td>
</tr>
<tr>
<th scope="row">4_</th>
<td>memory.grow</td>
<td>i32.const</td>
<td>i64.const</td>
<td>f32.const</td>
<td>f64.const</td>
<td>i32.eqz</td>
<td>i32.eq</td>
<td>i32.ne</td>
<td>i32.lt_s</td>
<td>i32.lt_u</td>
<td>i32.gt_s</td>
<td>i32.gt_u</td>
<td>i32.le_s</td>
<td>i32.le_u</td>
<td>i32.ge_s</td>
<td>i32.ge_u</td>
</tr>
<tr>
<th scope="row">5_</th>
<td>i64.eqz</td>
<td>i64.eq</td>
<td>i64.ne</td>
<td>i64.lt_s</td>
<td>i64.lt_u</td>
<td>i64.gt_s</td>
<td>i64.gt_u</td>
<td>i64.le_s</td>
<td>i64.le_u</td>
<td>i64.ge_s</td>
<td>i64.ge_u</td>
<td>f32.eq</td>
<td>f32.ne</td>
<td>f32.lt</td>
<td>f32.gt</td>
<td>f32.le</td>
</tr>
<tr>
<th scope="row">6_</th>
<td>f32.ge</td>
<td>f64.eq</td>
<td>f64.ne</td>
<td>f64.lt</td>
<td>f64.gt</td>
<td>f64.le</td>
<td>f64.ge</td>
<td>i32.clz</td>
<td>i32.ctz</td>
<td>i32.popcnt</td>
<td>i32.add</td>
<td>i32.sub</td>
<td>i32.mul</td>
<td>i32.div_s</td>
<td>i32.div_u</td>
<td>i32.rem_s</td>
</tr>
<tr>
<th scope="row">7_</th>
<td>i32.rem_u</td>
<td>i32.and</td>
<td>i32.or</td>
<td>i32.xor</td>
<td>i32.shl</td>
<td>i32.shr_s</td>
<td>i32.shr_u</td>
<td>i32.rotl</td>
<td>i32.rotr</td>
<td>i64.clz</td>
<td>i64.ctz</td>
<td>i64.popcnt</td>
<td>i64.add</td>
<td>i64.sub</td>
<td>i64.mul</td>
<td>i64.div_s</td>
</tr>
<tr>
<th scope="row">8_</th>
<td>i64.div_u</td>
<td>i64.rem_s</td>
<td>i64.rem_u</td>
<td>i64.and</td>
<td>i64.or</td>
<td>i64.xor</td>
<td>i64.shl</td>
<td>i64.shr_s</td>
<td>i64.shr_u</td>
<td>i64.rotl</td>
<td>i64.rotr</td>
<td>f32.abs</td>
<td>f32.neg</td>
<td>f32.ceil</td>
<td>f32.floor</td>
<td>f32.trunc</td>
</tr>
<tr>
<th scope="row">9_</th>
<td>f32.nearest</td>
<td>f32.sqrt</td>
<td>f32.add</td>
<td>f32.sub</td>
<td>f32.mul</td>
<td>f32.div</td>
<td>f32.min</td>
<td>f32.max</td>
<td>f32.copysign</td>
<td>f64.abs</td>
<td>f64.neg</td>
<td>f64.ceil</td>
<td>f64.floor</td>
<td>f64.trunc</td>
<td>f64.nearest</td>
<td>f64.sqrt</td>
</tr>
<tr>
<th scope="row">A_</th>
<td>f64.add</td>
<td>f64.sub</td>
<td>f64.mul</td>
<td>f64.div</td>
<td>f64.min</td>
<td>f64.max</td>
<td>f64.copysign</td>
<td>i32.wrap_i64</td>
<td>i32.trunc_f32_s</td>
<td>i32.trunc_f32_u</td>
<td>i32.trunc_f64_s</td>
<td>i32.trunc_f64_u</td>
<td>i64.extend_i32_s</td>
<td>i64.extend_i32_u</td>
<td>i64.trunc_f32_s</td>
<td>i64.trunc_f32_u</td>
</tr>
<tr>
<th scope="row">B_</th>
<td>i64.trunc_f64_s</td>
<td>i64.trunc_f64_u</td>
<td>f32.convert_i32_s</td>
<td>f32.convert_i32_u</td>
<td>f32.convert_i64_s</td>
<td>f32.convert_i64_u</td>
<td>f32.demote_f64</td>
<td>f64.convert_i32_s</td>
<td>f64.convert_i32_u</td>
<td>f64.convert_i64_s</td>
<td>f64.convert_i64_u</td>
<td>f64.promote_f32</td>
<td>i32.reinterpret_f32</td>
<td>i64.reinterpret_f64</td>
<td>f32.reinterpret_i32</td>
<td>f64.reinterpret_i64</td>
</tr>
<tr>
<th scope="row">C_</th>
<td>*i32.extend8_s</td>
<td>*i32.extend16_s</td>
<td>*i64.extend8_s</td>
<td>*i64.extend16_s</td>
<td>*i64.extend32_s</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<th scope="row">D_</th>
<td>*ref.null</td>
<td>*ref.is_null</td>
<td>*ref.func</td>
<td>*ref.as_non_null</td>
<td>*br_on_null</td>
<td>&nbsp;</td>
<td>*br_on_non_null</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<th scope="row">E_</th>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<th scope="row">F_</th>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>***</td>
<td>*SIMD</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>
<br/>
<b>** 0xFC proposals</b>
</p>
<table id="opcodes_FC">
<thead>
<tr>
<th>&nbsp;</th>
<th>_0</th>
<th>_1</th>
<th>_2</th>
<th>_3</th>
<th>_4</th>
<th>_5</th>
<th>_6</th>
<th>_7</th>
<th>_8</th>
<th>_9</th>
<th>_A</th>
<th>_B</th>
<th>_C</th>
<th>_D</th>
<th>_E</th>
<th>_F</th>
</tr>
</thead>
<tbody>
<tr>
<th scope="row">FC 0_</th>
<td class="reserved"><span>i32.trunc_sat_f32_s</span></td>
<td class="reserved"><span>i32.trunc_sat_f32_u</span></td>
<td class="reserved"><span>i32.trunc_sat_f64_s</span></td>
<td class="reserved"><span>i32.trunc_sat_f64_u</span></td>
<td class="reserved"><span>i64.trunc_sat_f32_s</span></td>
<td class="reserved"><span>i64.trunc_sat_f32_u</span></td>
<td class="reserved"><span>i64.trunc_sat_f64_s</span></td>
<td class="reserved"><span>i64.trunc_sat_f64_u</span></td>
<td class="reserved"><span>memory.init</span></td>
<td class="reserved"><span>data.drop</span></td>
<td class="reserved"><span>memory.copy</span></td>
<td class="reserved"><span>memory.fill</span></td>
<td class="reserved"><span>table.init</span></td>
<td class="reserved"><span>elem.drop</span></td>
<td class="reserved"><span>table.copy</span></td>
<td class="reserved"><span>table.grow</span></td>
</tr>
<tr>
<th scope="row">FC 1_</th>
<td class="reserved"><span>table.size</span></td>
<td class="reserved"><span>table.fill</span></td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
<td class="reserved">&nbsp;</td>
</tr>
</tbody></table>
<br/>
<b>** SIMD opcodes</b>
</p>
<table id="opcodes_FD">
<thead>
<tr>
<th>&nbsp;</th>
<th>_0</th>
<th>_1</th>
<th>_2</th>
<th>_3</th>
<th>_4</th>
<th>_5</th>
<th>_6</th>
<th>_7</th>
<th>_8</th>
<th>_9</th>
<th>_A</th>
<th>_B</th>
<th>_C</th>
<th>_D</th>
<th>_E</th>
<th>_F</th>
</tr>
</thead>
<tbody>
<tr>
<th scope="row">FD 0_</th>
<td><span>v128.load</span></td>
<td><span>v128.load8x8_s</span></td>
<td><span>v128.load8x8_u</span></td>
<td><span>v128.load16x4_s</span></td>
<td><span>v128.load16x4_u</span></td>
<td><span>v128.load32x2_s</span></td>
<td><span>v128.load32x2_u</span></td>
<td><span>v128.load8_splat</span></td>
<td><span>v128.load16_splat</span></td>
<td><span>v128.load32_splat</span></td>
<td><span>v128.load64_splat</span></td>
<td><span>v128.store</span></td>
<td><span>v128.const</span></td>
<td><span>i8x16.shuffle</span></td>
<td><span>i8x16.swizzle</span></td>
<td><span>i8x16.splat</span></td>
</tr>
<tr>
<th scope="row">FD 1_</th>
<td><span>i16x8.splat</span></td>
<td><span>i32x4.splat</span></td>
<td><span>i64x2.splat</span></td>
<td><span>f32x4.splat</span></td>
<td><span>f64x2.splat</span></td>
<td><span>i8x16.extract_lane_s</span></td>
<td><span>i8x16.extract_lane_u</span></td>
<td><span>i8x16.replace_lane</span></td>
<td><span>i16x8.extract_lane_s</span></td>
<td><span>i16x8.extract_lane_u</span></td>
<td><span>i16x8.replace_lane</span></td>
<td><span>i32x4.extract_lane</span></td>
<td><span>i32x4.replace_lane</span></td>
<td><span>i64x2.extract_lane</span></td>
<td><span>i64x2.replace_lane</span></td>
<td><span>f32x4.extract_lane</span></td>
</tr>
<tr>
<th scope="row">FD 2_</th>
<td><span>f32x4.replace_lane</span></td>
<td><span>f64x2.extract_lane</span></td>
<td><span>f64x2.replace_lane</span></td>
<td><span>i8x16.eq</span></td>
<td><span>i8x16.ne</span></td>
<td><span>i8x16.lt_s</span></td>
<td><span>i8x16.lt_u</span></td>
<td><span>i8x16.gt_s</span></td>
<td><span>i8x16.gt_u</span></td>
<td><span>i8x16.le_s</span></td>
<td><span>i8x16.le_u</span></td>
<td><span>i8x16.ge_s</span></td>
<td><span>i8x16.ge_u</span></td>
<td><span>i16x8.eq</span></td>
<td><span>i16x8.ne</span></td>
<td><span>i16x8.lt_s</span></td>
</tr>
<tr>
<th scope="row">FD 3_</th>
<td><span>i16x8.lt_u</span></td>
<td><span>i16x8.gt_s</span></td>
<td><span>i16x8.gt_u</span></td>
<td><span>i16x8.le_s</span></td>
<td><span>i16x8.le_u</span></td>
<td><span>i16x8.ge_s</span></td>
<td><span>i16x8.ge_u</span></td>
<td><span>i32x4.eq</span></td>
<td><span>i32x4.ne</span></td>
<td><span>i32x4.lt_s</span></td>
<td><span>i32x4.lt_u</span></td>
<td><span>i32x4.gt_s</span></td>
<td><span>i32x4.gt_u</span></td>
<td><span>i32x4.le_s</span></td>
<td><span>i32x4.le_u</span></td>
<td><span>i32x4.ge_s</span></td>
</tr>
<tr>
<th scope="row">FD 4_</th>
<td><span>i32x4.ge_u</span></td>
<td><span>f32x4.eq</span></td>
<td><span>f32x4.ne</span></td>
<td><span>f32x4.lt</span></td>
<td><span>f32x4.gt</span></td>
<td><span>f32x4.le</span></td>
<td><span>f32x4.ge</span></td>
<td><span>f64x2.eq</span></td>
<td><span>f64x2.ne</span></td>
<td><span>f64x2.lt</span></td>
<td><span>f64x2.gt</span></td>
<td><span>f64x2.le</span></td>
<td><span>f64x2.ge</span></td>
<td><span>v128.not</span></td>
<td><span>v128.and</span></td>
<td><span>v128.andnot</span></td>
</tr>
<tr>
<th scope="row">FD 5_</th>
<td><span>v128.or</span></td>
<td><span>v128.xor</span></td>
<td><span>v128.bitselect</span></td>
<td><span>v128.any_true</span></td>
<td><span>v128.load8_lane</span></td>
<td><span>v128.load16_lane</span></td>
<td><span>v128.load32_lane</span></td>
<td><span>v128.load64_lane</span></td>
<td><span>v128.store8_lane</span></td>
<td><span>v128.store16_lane</span></td>
<td><span>v128.store32_lane</span></td>
<td><span>v128.store64_lane</span></td>
<td><span>v128.load32_zero</span></td>
<td><span>v128.load64_zero</span></td>
<td><span>f32x4.demote_f64x2_zero</span></td>
<td><span>f64x2.promote_low_f32x4</span></td>
</tr>
<tr>
<th scope="row">FD 6_</th>
<td><span>i8x16.abs</span></td>
<td><span>i8x16.neg</span></td>
<td><span>i8x16.popcnt</span></td>
<td><span>i8x16.all_true</span></td>
<td><span>i8x16.bitmask</span></td>
<td><span>i8x16.narrow_i16x8_s</span></td>
<td><span>i8x16.narrow_i16x8_u</span></td>
<td><span>f32x4.ceil</span></td>
<td><span>f32x4.floor</span></td>
<td><span>f32x4.trunc</span></td>
<td><span>f32x4.nearest</span></td>
<td><span>i8x16.shl</span></td>
<td><span>i8x16.shr_s</span></td>
<td><span>i8x16.shr_u</span></td>
<td><span>i8x16.add</span></td>
<td><span>i8x16.add_sat_s</span></td>
</tr>
<tr>
<th scope="row">FD 7_</th>
<td><span>i8x16.add_sat_u</span></td>
<td><span>i8x16.sub</span></td>
<td><span>i8x16.sub_sat_s</span></td>
<td><span>i8x16.sub_sat_u</span></td>
<td><span>f64x2.ceil</span></td>
<td><span>f64x2.floor</span></td>
<td><span>i8x16.min_s</span></td>
<td><span>i8x16.min_u</span></td>
<td><span>i8x16.max_s</span></td>
<td><span>i8x16.max_u</span></td>
<td><span>f64x2.trunc</span></td>
<td><span>i8x16.avgr_u</span></td>
<td><span>i16x8.extadd_pairwise_i8x16_s</span></td>
<td><span>i16x8.extadd_pairwise_i8x16_u</span></td>
<td><span>i32x4.extadd_pairwise_i16x8_s</span></td>
<td><span>i32x4.extadd_pairwise_i16x8_u</span></td>
</tr>
<tr>
<th scope="row">FD 8_</th>
<td><span>i16x8.abs</span></td>
<td><span>i16x8.neg</span></td>
<td><span>i16x8.q15mulr_sat_s</span></td>
<td><span>i16x8.all_true</span></td>
<td><span>i16x8.bitmask</span></td>
<td><span>i16x8.narrow_i32x4_s</span></td>
<td><span>i16x8.narrow_i32x4_u</span></td>
<td><span>i16x8.extend_low_i8x16_s</span></td>
<td><span>i16x8.extend_high_i8x16_s</span></td>
<td><span>i16x8.extend_low_i8x16_u</span></td>
<td><span>i16x8.extend_high_i8x16_u</span></td>
<td><span>i16x8.shl</span></td>
<td><span>i16x8.shr_s</span></td>
<td><span>i16x8.shr_u</span></td>
<td><span>i16x8.add</span></td>
<td><span>i16x8.add_sat_s</span></td>
</tr>
<tr>
<th scope="row">FD 9_</th>
<td><span>i16x8.add_sat_u</span></td>
<td><span>i16x8.sub</span></td>
<td><span>i16x8.sub_sat_s</span></td>
<td><span>i16x8.sub_sat_u</span></td>
<td><span>f64x2.nearest</span></td>
<td><span>i16x8.mul</span></td>
<td><span>i16x8.min_s</span></td>
<td><span>i16x8.min_u</span></td>
<td><span>i16x8.max_s</span></td>
<td><span>i16x8.max_u</span></td>
<td>&nbsp;</td>
<td><span>i16x8.avgr_u</span></td>
<td><span>i16x8.extmul_low_i8x16_s</span></td>
<td><span>i16x8.extmul_high_i8x16_s</span></td>
<td><span>i16x8.extmul_low_i8x16_u</span></td>
<td><span>i16x8.extmul_high_i8x16_u</span></td>
</tr>
<tr>
<th scope="row">FD A_</th>
<td><span>i32x4.abs</span></td>
<td><span>i32x4.neg</span></td>
<td>&nbsp;</td>
<td><span>i32x4.all_true</span></td>
<td><span>i32x4.bitmask</span></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><span>i32x4.extend_low_i16x8_s</span></td>
<td><span>i32x4.extend_high_i16x8_s</span></td>
<td><span>i32x4.extend_low_i16x8_u</span></td>
<td><span>i32x4.extend_high_i16x8_u</span></td>
<td><span>i32x4.shl</span></td>
<td><span>i32x4.shr_s</span></td>
<td><span>i32x4.shr_u</span></td>
<td><span>i32x4.add</span></td>
<td>&nbsp;</td>
</tr>
<tr>
<th scope="row">FD B_</th>
<td>&nbsp;</td>
<td><span>i32x4.sub</span></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><span>i32x4.mul</span></td>
<td><span>i32x4.min_s</span></td>
<td><span>i32x4.min_u</span></td>
<td><span>i32x4.max_s</span></td>
<td><span>i32x4.max_u</span></td>
<td><span>i32x4.dot_i16x8_s</span></td>
<td>&nbsp;</td>
<td><span>i32x4.extmul_low_i16x8_s</span></td>
<td><span>i32x4.extmul_high_i16x8_s</span></td>
<td><span>i32x4.extmul_low_i16x8_u</span></td>
<td><span>i32x4.extmul_high_i16x8_u</span></td>
</tr>
<tr>
<th scope="row">FD C_</th>
<td><span>i64x2.abs</span></td>
<td><span>i64x2.neg</span></td>
<td>&nbsp;</td>
<td><span>i64x2.all_true</span></td>
<td><span>i64x2.bitmask</span></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><span>i64x2.extend_low_i32x4_s</span></td>
<td><span>i64x2.extend_high_i32x4_s</span></td>
<td><span>i64x2.extend_low_i32x4_u</span></td>
<td><span>i64x2.extend_high_i32x4_u</span></td>
<td><span>i64x2.shl</span></td>
<td><span>i64x2.shr_s</span></td>
<td><span>i64x2.shr_u</span></td>
<td><span>i64x2.add</span></td>
<td>&nbsp;</td>
</tr>
<tr>
<th scope="row">FD D_</th>
<td>&nbsp;</td>
<td><span>i64x2.sub</span></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><span>i64x2.mul</span></td>
<td><span>i64x2.eq</span></td>
<td><span>i64x2.ne</span></td>
<td><span>i64x2.lt_s</span></td>
<td><span>i64x2.gt_s</span></td>
<td><span>i64x2.le_s</span></td>
<td><span>i64x2.ge_s</span></td>
<td><span>i64x2.extmul_low_i32x4_s</span></td>
<td><span>i64x2.extmul_high_i32x4_s</span></td>
<td><span>i64x2.extmul_low_i32x4_u</span></td>
<td><span>i64x2.extmul_high_i32x4_u</span></td>
</tr>
<tr>
<th scope="row">FD E_</th>
<td><span>f32x4.abs</span></td>
<td><span>f32x4.neg</span></td>
<td>&nbsp;</td>
<td><span>f32x4.sqrt</span></td>
<td><span>f32x4.add</span></td>
<td><span>f32x4.sub</span></td>
<td><span>f32x4.mul</span></td>
<td><span>f32x4.div</span></td>
<td><span>f32x4.min</span></td>
<td><span>f32x4.max</span></td>
<td><span>f32x4.pmin</span></td>
<td><span>f32x4.pmax</span></td>
<td><span>f64x2.abs</span></td>
<td><span>f64x2.neg</span></td>
<td>&nbsp;</td>
<td><span>f64x2.sqrt</span></td>
</tr>
<tr>
<th scope="row">FD F_</th>
<td><span>f64x2.add</span></td>
<td><span>f64x2.sub</span></td>
<td><span>f64x2.mul</span></td>
<td><span>f64x2.div</span></td>
<td><span>f64x2.min</span></td>
<td><span>f64x2.max</span></td>
<td><span>f64x2.pmin</span></td>
<td><span>f64x2.pmax</span></td>
<td><span>i32x4.trunc_sat_f32x4_s</span></td>
<td><span>i32x4.trunc_sat_f32x4_u</span></td>
<td><span>f32x4.convert_i32x4_s</span></td>
<td><span>f32x4.convert_i32x4_u</span></td>
<td><span>i32x4.trunc_sat_f64x2_s_zero</span></td>
<td><span>i32x4.trunc_sat_f64x2_u_zero</span></td>
<td><span>f64x2.convert_low_i32x4_s</span></td>
<td><span>f64x2.convert_low_i32x4_u</span></td>
</tr>
</tbody></table>

<div style="display: none"> 

<!-- Help to be shown in popups. --> 
<!-- Ordered by hex code, except when two or more items have the same (or very similar) text, where they are grouped together. -->

<div id="0x00">
	<p>The unreachable instruction causes an unconditional trap.</p>
	<p>A trap immediately aborts execution. Traps cannot be handled by WebAssembly code, but are reported to the outside environment, where they typically can be caught.</p>
	<p><h3>Followed by:</h3>
		<span class="op-imm-args"></span>Note: Any instructions following must be valid. <!-- well-typed? -->
	</p>
	<p><h3>Stack:</h3><span class="op-type large">[t<span class="supsub"><sup>∗</sup><sub>1</sub></span>] → [t<span class="supsub"><sup>∗</sup><sub>2</sub></span>]</span></p>
	<p><b>stack-polymorphic</b>: performs an <i>unconditional control transfer</i>.</p>
</div>
<div id="0x01">
	<p>The nop instruction does nothing.</p>
	<p><h3>Stack:</h3><span class="op-type">[] → []</span></p>
</div>
<div id="0x02">
	<span class=immediate-args>[t<sup>?</sup>]</span>
	<p>the beginning of a block construct, a sequence of instructions with a label at the end.</p>
	<p><h3>Followed by:</h3>
		<ol>
			<li>i8 <i>rt</i> : blocktype — 0x40 = [], 0x7F = [i32], 0x7E = [i64], 0x7D = [f32], 0x7C = [f64]</li>
			<li>instructions</li> 
			<li>0x0B — end</li>
		</ol> 
	</p>
	<p><h3>Stack:</h3><span class="op-type">[] → [t<sup>∗</sup>]</span></p>
	<p>The result type of the instructions must match the blocktype. <!-- aka block's annotation [t<sup>∗</sup>] --></p> <!-- TODO: write this in plain english. e.g. "For example, if the rt is 0x7F, then the instructions must push only one i32 value to the stack."-->
	<p>The <i>block</i>, <i>loop</i> and <i>if</i> instructions are structured instructions. They bracket nested sequences of instructions, called blocks, terminated with, or separated by, <i>end</i> or <i>else</i> pseudo-instructions. They must be well-nested.</p>
</div>
<div id="0x03">
	<span class=immediate-args>[t<sup>?</sup>]</span>
	<p>a block with a label at the beginning which may be used to form loops</p>
	<p><h3>Followed by:</h3>
		<ol>
			<li>i8 <i>rt</i> : blocktype — 0x40 = [], 0x7F = [i32], 0x7E = [i64], 0x7D = [f32], 0x7C = [f64]</li>
			<li>instructions</li> 
			<li>0x0B — end</li>
		</ol> 
	</p>
	<p><h3>Stack:</h3><span class="op-type">[] → [t<sup>∗</sup>]</span></p>
</div>
<div id="0x04">
	<span class=immediate-args>[t<sup>?</sup>]</span>
	<p>the beginning of an if construct with an implicit <i>then</i> block</p>
	<p><h3>Followed by:</h3>
		<ol>
			<li>i8 <i>rt</i> : blocktype — 0x40 = [], 0x7F = [i32], 0x7E = [i64], 0x7D = [f32], 0x7C = [f64]</li>
			<li>instructions<sub>1</sub></li> 
			<li>0x0B — end</li>
		</ol> 
		or
		<ol>
			<li>i8 <i>rt</i> : blocktype</li>
			<li>instructions<sub>1</sub></li> 
			<li>0x05 — else</li>
			<li>instructions<sub>2</sub></li> 
			<li>0x0B — end</li>
		</ol> 
	</p>
	<p>
		<h3>Stack:</h3>
		<span class="op-type">[i32] → [t<sup>∗</sup>]</span><br/>
		<span class="op-type">i32 <i>c</i> → [t<sup>∗</sup>]</span><br/>
		<span class="op-type">if <i>c</i> is non-zero, enter block instructions<sub>1</sub>, else enter block instructions<sub>2</sub></span>
	</p>
</div>
<div id="0x05"><p>Marks the else block of an <i>if</i>.</p></div>
<div id="0x0B"><p>Marks the end of a <i>block</i>, <i>loop</i>, <i>if</i>, or function.</p></div>
<div id="0x0C">
	<span class="immediate-args">l</span>
	<p>Branch to a given label in an enclosing construct.</p>
	<p>Performs an unconditional branch.</p>
	<p>
		<h3>Followed by:</h3><span class="op-imm-args">u32 <i>l</i> : labelidx</span>
	</p>
	<p>Label 0 refers to the innermost structured control instruction enclosing the referring branch instruction, while increasing indices refer to those farther out.</p>
	<p>
		<h3>Stack:</h3><span class="op-type large">[t<span class="supsub"><sup>∗</sup><sub>1</sub></span> t<sup>?</sup>] → [t<span class="supsub"><sup>∗</sup><sub>2</sub></span>]</span>
		<!--  <br/> TODO
		<span class="op-type">labels, <i>val</i> : result → val</span>
		<span class="op-type">vec( label { instr∗ } ), vec( val ) : arguments </span> -->
	</p>
	<p>A branch targeting a <i>block</i> or <i>if</i> behaves like a break statement in most C-like languages, while a branch targeting a <i>loop</i> behaves like a continue statement.</p>
	<p><b>stack-polymorphic</b>: performs an <i>unconditional control transfer</i>.</p>
</div>
<div id="0x0D">
	<span class="immediate-args">l</span>
	<p>Performs a conditional branch, branching if i32 <i>c</i> is non-zero.</p>
	<p>Conditionally branch to a given label in an enclosing construct.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args">u32 <i>l</i> : labelidx</span></p>
	<p>
		<h3>Stack:</h3><span class="op-type">[t<sup>?</sup> i32] → [t<sup>?</sup>]</span>
	</p>
</div>
<div id="0x0E">
	<span class="immediate-args">l* l</span>
	<p>A jump table which jumps to a label in an enclosing construct.</p>
	<p>Performs an indirect branch through an operand indexing into the label vector that is an immediate to the instruction, or to a default target if the operand is out of bounds.</p>
	<p><h3>Followed by:</h3>
		<ol>
			<li><span class="op-imm-args">u32 <i>l*</i> : vec( labelidx )</span></li>
			<li><span class="op-imm-args">u32 <i>l</i> : labelidx </span></li>
		</ol>
	</p>
	<p>
		<h3>Stack:</h3>
		<span class="op-type large">[t<span class="supsub"><sup>∗</sup><sub>1</sub></span> t<sup>?</sup> i32] → [t<span class="supsub"><sup>∗</sup><sub>2</sub></span>]</span>
		<br/>
	</p>
	<p><b>stack-polymorphic</b>: performs an <i>unconditional control transfer</i>.</p>
</div>
<div id="0x0F">
	<p>return zero or more values from this function.</p>
	<p>The return instruction is a shortcut for an unconditional branch to the outermost block, which implicitly is the body of the current function.</p>
	<p><h3>Stack:</h3><span class="op-type large">[t<span class="supsub"><sup>∗</sup><sub>1</sub></span> t<sup>?</sup>] → [t<span class="supsub"><sup>∗</sup><sub>2</sub></span>]</span></p>
	<p><b>stack-polymorphic</b>: performs an <i>unconditional control transfer</i>.</p>
</div>
<div id="0x10">
	<span class="immediate-args">x</span>
	<p>The call instruction invokes another function, consuming the necessary arguments from the stack and returning the result values of the call. </p>
	<p><h3>Followed by:</h3><span class="op-imm-args">u32 <i>x</i> : funcidx</span></p>
	<p><h3>Stack:</h3><span class="op-type large">[t<span class="supsub"><sup>∗</sup><sub>1</sub></span>] → [t<span class="supsub"><sup>∗</sup><sub>2</sub></span>]</span></p>
</div>
<div id="0x11">
	<span class="immediate-args">x</span>
	<p>The call_indirect instruction calls a function indirectly through an operand indexing into a table.</p>
	<p><h3>Followed by:</h3>
		<ol>
			<li><span class="op-imm-args">u32 <i>x</i> : typeidx</span></li>
			<li><span class="op-imm-args">0x00</span> — zero byte</li>
		</ol>
	</p>
	<p><h3>Stack:</h3><span class="op-type">[t<sup>?</sup> i32] → [t<sup>?</sup>]</span></p>
	<p>In future versions of WebAssembly, the zero byte may be used to index additional tables.</p>
</div>

<div id="0x1A">
	<p>The drop instruction simply throws away a single operand.</p>
	<p><h3>Stack:</h3><span class="op-type">[t] → []</span> (value-polymorphic) <!-- https://webassembly.github.io/spec/core/valid/instructions.html#polymorphism --></p>
</div>
<div id="0x1B">
	<p>The select instruction selects one of its first two operands based on whether its third operand is zero or not.</p>
	<p><h3>Stack:</h3><span class="op-type">[t t i32] → [t]</span> (value-polymorphic) <!-- https://webassembly.github.io/spec/core/valid/instructions.html#polymorphism --></p>
</div>
<div id="0x20">
	<span class="immediate-args">x</span>
	<p>This instruction gets the value of a variable.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args">u32 <i>x</i> : localidx</span></p>
	<p><h3>Stack:</h3><span class="op-type">[] → [t]</span></p>
	<p>The index space for locals is only accessible inside a function and includes the parameters of that function, which precede the local variables.</p>
	<p>The <i>locals</i> context refers to the list of locals declared in the current function (including parameters), represented by their value type.</p>
</div>
<div id="0x21">
	<span class="immediate-args">x</span>
	<p>This instruction sets the value of a variable.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args">u32 <i>x</i> : localidx</span></p>
	<p><h3>Stack:</h3><span class="op-type">[t] → []</span></p>
	<p>The index space for locals is only accessible inside a function and includes the parameters of that function, which precede the local variables.</p>
</div>
<div id="0x22">
	<span class="immediate-args">x</span>
	<p>The local.tee instruction is like local.set but also returns its argument.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args">u32 <i>x</i> : localidx</span></p>
	<p><h3>Stack:</h3><span class="op-type">[t] → [t]</span></p>
	<p>The index space for locals is only accessible inside a function and includes the parameters of that function, which precede the local variables.</p>
</div>
<div id="0x23">
	<span class="immediate-args">x</span>
	<p>This instruction gets the value of a variable.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args">u32 <i>x</i> : globalidx</span></p>
	<p><h3>Stack:</h3><span class="op-type">[] → [t]</span></p>
	<p>The <i>globals</i> context is the list of globals declared in the current module, represented by their global type.</p>
</div>
<div id="0x24">
	<span class="immediate-args">x</span>
	<p>This instruction sets the value of a variable </p>
	<p><h3>Followed by:</h3><span class="op-imm-args">u32 <i>x</i> : globalidx</span></p>
	<p><h3>Stack:</h3><span class="op-type">[t] → []</span></p>
</div>

<div id="0x28">
	<span class="immediate-args">m</span>
	<p>load 4 bytes as i32.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args"><i>m</i> : memarg { u32 offset, u32 align }</span></p>
	<p>
		<h3>Stack:</h3>
		<span class="op-type">[i32] → [i32]</span> <br/>
		<span class="op-type">i : address-operand → c : result</span>
	</p>
	<p>Memory is accessed with load and store instructions for the different value types. They all take a memory immediate <i>memarg</i> that contains an address offset and the expected alignment.<!-- (expressed as the exponent of a power of 2). --></p>
	<p>The immediate value memarg.align is an alignment hint about the effective-address. It is a power-of 2 encoded as log2(memarg.align). In practice, its value may be: 0 (8-bit), 1 (16-bit), 2 (32-bit), or (64-bit; used only with wasm64). <!-- https://rsms.me/wasm-intro#addressing-memory --></p>
	<p><code>effective-address = address-operand + memarg.offset <!-- address-operand + offset-immediate --></code></p>
	<p>If memarg.align is incorrect it is considered "misaligned". Misaligned access still has the same behavior as aligned access, only possibly much slower.</p>
</div>
<div id="0x29">
	<span class="immediate-args">m</span>
	<p>load 8 bytes as i64.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args"><i>m</i> : memarg { u32 offset, u32 align }</span></p>
	<p>
		<h3>Stack:</h3>
		<span class="op-type">[i32] → [i64]</span>
	</p>
	<p>The static address offset is added to the dynamic address operand, yielding a 33 bit effective address that is the zero-based index at which the memory is accessed. All values are read and written in little endian byte order. A trap results if any of the accessed memory bytes lies outside the address range implied by the memory’s current size.</p>
</div>
<div id="0x2A">
	<span class="immediate-args">m</span>
	<p>load 4 bytes as f32.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [f32]</span></p>
	<p>Note: When a number is stored into memory, it is converted into a sequence of bytes in little endian byte order.</p>
</div>
<div id="0x2B">
	<span class="immediate-args">m</span>
	<p>load 8 bytes as f64.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [f64]</span></p>
</div>
<div id="0x2C">
	<span class="immediate-args">m</span>
	<p>load 1 byte and sign-extend i8 to i32.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
	<p>Integer loads and stores can optionally specify a storage size that is smaller than the bit width of the respective value type. In the case of loads, a sign extension mode sx (s|u) is then required to select appropriate behavior.</p>
</div>
<div id="0x2D">
	<span class="immediate-args">m</span>
	<p>load 1 byte and zero-extend i8 to i32</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
</div>
<div id="0x2E">
	<span class="immediate-args">m</span>
	<p>load 2 bytes and sign-extend i16 to i32</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
</div>
<div id="0x2F">
	<span class="immediate-args">m</span>
	<p>load 2 bytes and zero-extend i16 to i32</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
</div>
<div id="0x30">
	<span class="immediate-args">m</span>
	<p>load 1 byte and sign-extend i8 to i64</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>
<div id="0x31">
	<span class="immediate-args">m</span>
	<p>load 1 byte and zero-extend i8 to i64</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>
<div id="0x32">
	<span class="immediate-args">m</span>
	<p>load 2 bytes and sign-extend i16 to i64</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>
<div id="0x33">
	<span class="immediate-args">m</span>
	<p>load 2 bytes and zero-extend i16 to i64</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>
<div id="0x34">
	<span class="immediate-args">m</span>
	<p>load 4 bytes and sign-extend i16 to i64</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>
<div id="0x35">
	<span class="immediate-args">m</span>
	<p>load 4 bytes and zero-extend i16 to i64</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>
<div id="0x36">
	<span class="immediate-args">m</span>
	<p>store 4 bytes (no conversion)</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → []</span></p>
</div>
<div id="0x37">
	<span class="immediate-args">m</span>
	<p>store 8 bytes (no conversion)</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i64] → []</span></p>
</div>
<div id="0x38">
	<span class="immediate-args">m</span>
	<p>store 4 bytes (no conversion)</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 f32] → []</span></p>
</div>
<div id="0x39">
	<span class="immediate-args">m</span>
	<p>store 8 bytes (no conversion)</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 f64] → []</span></p>
</div>
<div id="0x3A">
	<span class="immediate-args">m</span>
	<p>wrap i32 to i8 and store 1 byte</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → []</span></p>
</div>
<div id="0x3B">
	<span class="immediate-args">m</span>
	<p>wrap i32 to i16 and store 2 bytes</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → []</span></p>
</div>
<div id="0x3C">
	<span class="immediate-args">m</span>
	<p>wrap i64 to i8 and store 1 byte</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i64] → []</span></p>
</div>
<div id="0x3D">
	<span class="immediate-args">m</span>
	<p>wrap i64 to i16 and store 2 bytes</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i64] → []</span></p>
</div>
<div id="0x3E">
	<span class="immediate-args">m</span>
	<p>wrap i64 to i32 and store 4 bytes</p>
	<p><h3>Stack:</h3>
		<span class="op-type">[i32 i64] → []</span><br/>
	</p>
</div>
<div id="0x3F">
	<p>The <b>memory.size</b> instruction returns the current size of a memory.</p>
	<p>Operates in units of page size. Each page is 65,536 bytes (64KB).</p>
	<p><h3>Stack:</h3><span class="op-type">[] → [i32]</span></p>
</div>
<div id="0x40">
	<p>The memory.grow instruction grows memory by a given delta and returns the previous size, or −1 if enough memory cannot be allocated.</p>
	<p>Operates in units of page size. Each page is 65,536 bytes (64KB).</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
</div>

<div id="0x41">
	<span class="immediate-args">n</span>
	<p>Push a 32-bit integer value to the stack.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args"><i>n</i> : i32</span></p>
	<p><h3>Stack:</h3><span class="op-type">[] → [i32]</span></p>
</div>
<div id="0x42">
	<span class="immediate-args">n</span>
	<p>Push a 64-bit integer value to the stack.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args"><i>n</i> : i64</span></p>
	<p><h3>Stack:</h3><span class="op-type">[] → [i64]</span></p>
</div>
<div id="0x43">
	<span class="immediate-args">z</span>
	<p>Push a 32-bit float value to the stack.</p>
	<p><h3>Followed by:</h3><span class="op-imm-args"><i>z</i> : f32</span></p>
	<p><h3>Stack:</h3><span class="op-type">[] → [f32]</span></p>
</div>
<div id="0x44">
	<p>Push a 64-bit float value to the stack.</p>
	<span class="immediate-args">z</span>
	<p><h3>Followed by:</h3><span class="op-imm-args"><i>z</i> : f64</span></p>
	<p><h3>Stack:</h3><span class="op-type">[] → [f64]</span></p>
</div>

<div id="0x45"><p>compare equal to zero.</p><p>Return 1 if operand is zero, 0 otherwise.</p><p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p></div>
<div id="0x50"><p>compare equal to zero.</p><p>Return 1 if operand is zero, 0 otherwise.</p><p><h3>Stack:</h3><span class="op-type">[i64] → [i32]</span></p></div>
<div id="0x46">
	<p class="bigsign">==</p>
	<p>sign-agnostic compare equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x51">
	<p class="bigsign">==</p>
	<p>sign-agnostic compare equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x47">
	<p class="bigsign">≠</p>
	<p>sign-agnostic compare unequal</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x52">
	<p class="bigsign">≠</p>
	<p>sign-agnostic compare unequal</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x48">
	<p class="bigsign">&lt;</p>
	<p>signed less than</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x53">
	<p class="bigsign">&lt;</p>
	<p>signed less than</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x49">
	<p class="bigsign">&lt;</p>
	<p>unsigned less than</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x54">
	<p class="bigsign">&lt;</p>
	<p>unsigned less than</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x4A">
	<p class="bigsign">&gt;</p>
	<p>signed greater than</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x55">
	<p class="bigsign">&gt;</p>
	<p>signed greater than</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x4B">
	<p class="bigsign">&gt;</p>
	<p>unsigned greater than</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x56">
	<p class="bigsign">&gt;</p>
	<p>unsigned greater than</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x4C">
	<p class="bigsign">≤</p>
	<p>signed less than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x57">
	<p class="bigsign">≤</p>
	<p>signed less than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x4D">
	<p class="bigsign">≤</p>
	<p>unsigned less than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x58">
	<p class="bigsign">≤</p>
	<p>unsigned less than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x4E">
	<p class="bigsign">≥</p>
	<p>signed greater than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x59">
	<p class="bigsign">≥</p>
	<p>signed greater than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>
<div id="0x4F">
	<p class="bigsign">≥</p>
	<p>unsigned greater than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x5A">
	<p class="bigsign">≥</p>
	<p>unsigned greater than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i32]</span></p>
</div>

<div id="0x5B">
	<p class="bigsign">==</p>
	<p>compare equal</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [i32]</span></p>
</div>
<div id="0x61">
	<p class="bigsign">==</p>
	<p>compare equal</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [i32]</span></p>
</div>
<div id="0x5C">
	<p class="bigsign">≠</p>
	<p>compare unordered or unequal</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [i32]</span></p>
</div>
<div id="0x62">
	<p class="bigsign">≠</p>
	<p>compare unordered or unequal</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [i32]</span></p>
</div>
<div id="0x5D">
	<p class="bigsign">&lt;</p>
	<p>less than</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [i32]</span></p>
</div>
<div id="0x63">
	<p class="bigsign">&lt;</p>
	<p>less than</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [i32]</span></p>
</div>
<div id="0x5E">
	<p class="bigsign">&gt;</p>
	<p>greater than</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [i32]</span></p>
</div>
<div id="0x64">
	<p class="bigsign">&gt;</p>
	<p> greater than</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [i32]</span></p>
</div>
<div id="0x5F">
	<p class="bigsign">≤</p>
	<p>less than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [i32]</span></p>
</div>
<div id="0x65">
	<p class="bigsign">≤</p>
	<p>less than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [i32]</span></p>
</div>
<div id="0x60">
	<p class="bigsign">≥</p>
	<p>greater than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [i32]</span></p>
</div>
<div id="0x66">
	<p class="bigsign">≥</p>
	<p>greater than or equal</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [i32]</span></p>
</div>

<div id="0x67">
	<p>sign-agnostic count leading zero bits</p>
	<p>Return the count of leading zero bits in i. All zero bits are considered leading if the value is zero.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
</div>
<div id="0x79">
	<p>sign-agnostic count leading zero bits</p>
	<p>Return the count of leading zero bits in i. All zero bits are considered leading if the value is zero.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [i64]</span></p>
</div>
<div id="0x68">
	<p>sign-agnostic count trailing zero bits</p>
	<p>Return the count of trailing zero bits in i. All zero bits are considered trailing if the value is zero.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
</div>
<div id="0x7A">
	<p>sign-agnostic count trailing zero bits</p>
	<p>Return the count of trailing zero bits in i. All zero bits are considered trailing if the value is zero.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [i64]</span></p>
</div>
<div id="0x69">
	<p>sign-agnostic count number of one bits</p>
	<p>Return the count of non-zero bits in i.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i32]</span></p>
</div>
<div id="0x7B">
	<p>sign-agnostic count number of one bits</p>
	<p>Return the count of non-zero bits in i.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [i64]</span></p>
</div>

<div id="0x6A">
	<p>sign-agnostic addition</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x7C">
	<p>sign-agnostic addition</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x6B">
	<p>sign-agnostic subtraction</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x7D">
	<p>sign-agnostic subtraction</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x6C">
	<p>sign-agnostic multiplication, modulo 2<sup>32</sup></p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x7E">
	<p>sign-agnostic multiplication, modulo 2<sup>64</sup></p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x6D">
	<p>signed division (result is truncated toward zero)</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x7F">
	<p>signed division (result is truncated toward zero)</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x6E">
	<p>unsigned division (result is floored)</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x80">
	<p>unsigned division (result is floored)</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x6F">
	<p>signed remainder (result has the sign of the dividend)</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x81">
	<p>signed remainder (result has the sign of the dividend)</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x70">
	<p>unsigned remainder</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x82">
	<p>unsigned remainder</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x71">
	<p>sign-agnostic bitwise <i>and</i>.</p>
	<p>Return the bitwise conjunction of 𝑖1 and 𝑖2.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x83">
	<p>sign-agnostic bitwise <i>and</i>.</p>
	<p>Return the bitwise conjunction of 𝑖1 and 𝑖2.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x72">
	<p>sign-agnostic bitwise <i>inclusive or</i>.</p>
	<p>Return the bitwise disjunction of 𝑖1 and 𝑖2.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x84">
	<p>sign-agnostic bitwise <i>inclusive or</i>.</p>
	<p>Return the bitwise disjunction of 𝑖1 and 𝑖2.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x73">
	<p>sign-agnostic bitwise <i>exclusive or</i>.</p>
	<p>Return the bitwise exclusive disjunction of 𝑖1 and 𝑖2.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x85">
	<p>sign-agnostic bitwise <i>exclusive or</i>.</p>
	<p>Return the bitwise exclusive disjunction of 𝑖1 and 𝑖2.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x74">
	<p>sign-agnostic shift left</p>
	<p>Return the result of shifting i1 left by k bits, modulo 2<sup>32</sup></p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x86">
	<p>sign-agnostic shift left</p>
	<p>Return the result of shifting i1 left by k bits, modulo 2<sup>64</sup></p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x75">
	<p>sign-replicating (arithmetic) shift right</p>
	<p>Return the result of shifting i1 right by k bits, extended with the most significant bit of the original value.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x87">
	<p>sign-replicating (arithmetic) shift right</p>
	<p>Return the result of shifting i1 right by k bits, extended with the most significant bit of the original value.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x76">
	<p>zero-replicating (logical) shift right</p>
	<p>Return the result of shifting i1 right by k bits, extended with 0 bits.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x88">
	<p>zero-replicating (logical) shift right</p>
	<p>Return the result of shifting i1 right by k bits, extended with 0 bits.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x77">
	<p>sign-agnostic rotate left</p>
	<p>Return the result of rotating i1 left by k bits.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x89">
	<p>sign-agnostic rotate left</p>
	<p>Return the result of rotating i1 left by k bits.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>
<div id="0x78">
	<p>sign-agnostic rotate right</p>
	<p>Return the result of rotating i1 right by k bits.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32 i32] → [i32]</span></p>
</div>
<div id="0x8A">
	<p>sign-agnostic rotate right</p>
	<p>Return the result of rotating i1 right by k bits.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64 i64] → [i64]</span></p>
</div>

<div id="0x8B">
	<p>absolute value</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f32]</span></p>
</div>
<div id="0x99">
	<p>absolute value</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f64]</span></p>
</div>
<div id="0x8C">
	<p>negation</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f32]</span></p>
</div>
<div id="0x9A">
	<p>negation</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f64]</span></p>
</div>
<div id="0x8D">
	<p>ceiling operator</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f32]</span></p>
</div>
<div id="0x9B">
	<p>ceiling operator</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f64]</span></p>
</div>
<div id="0x8E">
	<p>floor operator</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f32]</span></p>
</div>
<div id="0x9C">
	<p>floor operator</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f64]</span></p>
</div>
<div id="0x8F">
	<p>round to nearest integer towards zero</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f32]</span></p>
</div>
<div id="0x9D">
	<p>round to nearest integer towards zero</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f64]</span></p>
</div>
<div id="0x90">
	<p>round to nearest integer, ties to even</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f32]</span></p>
</div>
<div id="0x9E">
	<p>round to nearest integer, ties to even</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f64]</span></p>
</div>
<div id="0x91">
	<p>square root</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f32]</span></p>
</div>
<div id="0x9F">
	<p>square root</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f64]</span></p>
</div>

<div id="0x92">
	<p>addition</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [f32]</span></p>
</div>
<div id="0xA0">
	<p>addition</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [f64]</span></p>
</div>
<div id="0x93">
	<p>subtraction</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [f32]</span></p>
</div>
<div id="0xA1">
	<p>subtraction</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [f64]</span></p>
</div>
<div id="0x94">
	<p>multiplication</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [f32]</span></p>
</div>
<div id="0xA2">
	<p>multiplication</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [f64]</span></p>
</div>
<div id="0x95">
	<p>division</p>
	<p>partial function: division by 0 is undefined</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [f32]</span></p>
</div>
<div id="0xA3">
	<p>division</p>
	<p>partial function: division by 0 is undefined</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [f64]</span></p>
</div>
<div id="0x96">
	<p>minimum (binary operator); if either operand is NaN, returns NaN</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [f32]</span></p>
</div>
<div id="0xA4">
	<p>minimum (binary operator); if either operand is NaN, returns NaN</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [f64]</span></p>
</div>
<div id="0x97">
	<p>maximum (binary operator); if either operand is NaN, returns NaN</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [f32]</span></p>
</div>
<div id="0xA5">
	<p>maximum (binary operator); if either operand is NaN, returns NaN</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [f64]</span></p>
</div>
<div id="0x98">
	<p>If z1 and z2 have the same sign, then return z1. Else return z1 with negated sign.</p>
	<p><h3>Stack:</h3><span class="op-type">[f32 f32] → [f32]</span></p>
</div>
<div id="0xA6">
	<p>If z1 and z2 have the same sign, then return z1. Else return z1 with negated sign.</p>
	<p><h3>Stack:</h3><span class="op-type">[f64 f64] → [f64]</span></p>
</div>

<div id="0xA7">
	<p>wrap a 64-bit integer to a 32-bit integer.</p>
	<p>Return i modulo 2<sup>32</sup>.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [i32]</span></p>
</div>
<div id="0xA8">
	<p>truncate a 32-bit float to a signed 32-bit integer</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [i32]</span></p>
</div>
<div id="0xA9">
	<p>truncate a 32-bit float to an unsigned 32-bit integer</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [i32]</span></p>
</div>
<div id="0xAA">
	<p>truncate a 64-bit float to a signed 32-bit integer</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [i32]</span></p>
</div>
<div id="0xAB">
	<p>truncate a 64-bit float to an unsigned 32-bit integer</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [i32]</span></p>
</div>

<div id="0xAC">
	<p>extend a signed 32-bit integer to a 64-bit integer.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>
<div id="0xAD">
	<p>extend an unsigned 32-bit integer to a 64-bit integer.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [i64]</span></p>
</div>

<div id="0xAE">
	<p>truncate a 32-bit float to a signed 64-bit integer.</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [i64]</span></p>
</div>
<div id="0xAF">
	<p>truncate a 32-bit float to an unsigned 64-bit integer.</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [i64]</span></p>
</div>
<div id="0xB0">
	<p>truncate a 64-bit float to a signed 64-bit integer.</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [i64]</span></p>
</div>
<div id="0xB1">
	<p>truncate a 64-bit float to an unsigned 64-bit integer.</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [i64]</span></p>
</div>

<div id="0xB2">
	<p>convert a signed 32-bit integer to a 32-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [f32]</span></p>
</div>
<div id="0xB3">
	<p>convert an unsigned 32-bit integer to a 32-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [f32]</span></p>
</div>
<div id="0xB4">
	<p>convert a signed 64-bit integer to a 32-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [f32]</span></p>
</div>
<div id="0xB5">
	<p>convert an unsigned 64-bit integer to a 32-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [f32]</span></p>
</div>

<div id="0xB6">
	<p>demote a 64-bit float to a 32-bit float</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [f32]</span></p>
</div>

<div id="0xB7">
	<p>convert a signed 32-bit integer to a 64-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [f64]</span></p>
</div>
<div id="0xB8">
	<p>convert an unsigned 32-bit integer to a 64-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [f64]</span></p>
</div>
<div id="0xB9">
	<p>convert a signed 64-bit integer to a 64-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [f64]</span></p>
</div>
<div id="0xBA">
	<p>convert an unsigned 64-bit integer to a 64-bit float.</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [f64]</span></p>
</div>

<div id="0xBB">
	<p>promote a 32-bit float to a 64-bit float</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [f64]</span></p>
</div>

<div id="0xBC">
	<p>reinterpret the bits of a 32-bit float as a 32-bit integer</p>
	<p><h3>Stack:</h3><span class="op-type">[f32] → [i32]</span></p>
</div>
<div id="0xBD">
	<p>reinterpret the bits of a 64-bit float as a 64-bit integer</p>
	<p><h3>Stack:</h3><span class="op-type">[f64] → [i64]</span></p>
</div>
<div id="0xBE">
	<p>reinterpret the bits of a 32-bit integer as a 32-bit float</p>
	<p><h3>Stack:</h3><span class="op-type">[i32] → [f32]</span></p>
</div>
<div id="0xBF">
	<p>reinterpret the bits of a 64-bit integer as a 64-bit float</p>
	<p><h3>Stack:</h3><span class="op-type">[i64] → [f64]</span></p>
</div>

<div id="0x69_old_unused">
	<p></p>
	Stack:
	<span class="mopen">[</span><a href="#syntax-valtype"><span class="mord"><span class="mord mathsf">i</span><span class="mord mathsf">3</span><span class="mord mathsf">2</span></span></a><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><a href="#syntax-functype"><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></a><span class="mopen">[</span><a href="#syntax-valtype"><span class="mord"><span class="mord mathsf">i</span><span class="mord mathsf">3</span><span class="mord mathsf">2</span></span></a><span class="mclose">]</span>
	<!-- Numeric Instructions,  t.unop -->
	<div class="section" id="op-ipopcnt">
	<span id="id18②"></span>
	<h5 class="no-toc heading settled" data-level="4.3.2.20" id="-hrefop-ipopcntmathrmipopcnt_n-i"><span class="secno">4.3.2.20. </span><span class="content"><span class=" "><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><a href="#op-ipopcnt"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">p</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span></a><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathrm">i</span><span class="mclose">)</span></span></span></span></span></span></span></span><a class="self-link" href="#-hrefop-ipopcntmathrmipopcnt_n-i"></a></h5>
	<ul class="simple">
	<li>Return the count of non-zero bits in <span class=" "><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">i</span></span></span></span></span></span></span>.
	</li></ul>
	<div class=" "><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.209108em;vertical-align:-0.354554em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span style="top:-3.005446em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><a href="#op-ipopcnt"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">p</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span></a><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span style="top:-3.005446em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span style="top:-3.005446em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span style="top:-3.005446em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mrel"><span class="mord text"><span class="mord">if</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><a href="#aux-ibits"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mord mathrm">s</span></span></a><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace nobreak">&nbsp;</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace nobreak">&nbsp;</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></span></div>
	</div>
</div>
</div>

&nbsp;
<!--
<p>
<a href="https://github.com/WebAssembly/exception-handling/blob/master/proposals/Exceptions.md">Exception handling proposal</a>
<pre>
0x06 == try 	
0x07 == catch 	
0x08 == throw
0x09 == rethrow
0x0a == br_on_exn
-0x18 == exnref
</pre>
</p>
<p>
<a href="https://github.com/WebAssembly/tail-call">Tail Call proposal</a>
<pre>
0x12 == return_call 
0x13 == return_call_indirect
</pre>
</p>
-->
<!--
<p>
<a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions">Non-trapping Float-to-int Conversions proposal</a>
<pre>
0xfc 0x00 == i32.trunc_sat_f32_s
0xfc 0x01 == i32.trunc_sat_f32_u
0xfc 0x02 == i32.trunc_sat_f64_s
0xfc 0x03 == i32.trunc_sat_f64_u
0xfc 0x04 == i64.trunc_sat_f32_s
0xfc 0x05 == i64.trunc_sat_f32_u
0xfc 0x06 == i64.trunc_sat_f64_s
0xfc 0x07 == i64.trunc_sat_f64_u
</pre>
</p>
<p>
<a href="https://github.com/WebAssembly/reference-types">Reference Types proposal</a> [only 0xfc.. opcodes listed below] (22-Aug-2019)
<pre>
0xfc 0x08 == memory.init 
0xfc 0x09 == data.drop 
0xfc 0x0a == memory.copy 
0xfc 0x0b == memory.fill 
0xfc 0x0c == table.init 
0xfc 0x0d == elem.drop 
0xfc 0x0e == table.copy 
</pre>
</p>
<p><a href="https://github.com/webassembly/bulk-memory-operations">Bulk Memory proposal</a>
<pre>
0xfc 0x0f == table.grow 
0xfc 0x10 == table.size 
0xfc 0x11 == table.fill 		
</pre>
</p>
-->
<!--
<p>
<a href="https://github.com/WebAssembly/sign-extension-ops">Sign-extension operators proposal</a>
<pre>
0xC0 == i32.extend8_s
0xC1 == i32.extend16_s
0xC2 == i64.extend8_s
0xC3 == i64.extend16_s
0xC4 == i64.extend32_s
</pre>
</p>
-->
<!--<p>Gaps in the byte code ranges for encoding instructions are reserved for future extensions.</p>-->
<span>
	<p>
		<h2>Further reading</h2>
		<ul>
			<li><a href="https://webassembly.github.io/spec/">WebAssembly Specifications</a></li>
			<li><a href="https://developer.mozilla.org/en-US/docs/WebAssembly">WebAssembly</a> (MDN web docs; developer.mozilla.org)</li>
			<li><a href="https://rsms.me/wasm-intro">Introduction to WebAssembly</a> (Rasmus Andersson; rsms.me)</li>
		</ul>
	</p>
	<br>
	<p><a href="https://github.com/pengowray/wasm-ops">View on GitHub</a></p>
</span>
</body>
</html>